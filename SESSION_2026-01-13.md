# Session Summary - January 13, 2026

## Overview
Performance optimizations and state persistence features. Reduced queue contention through conditional statistics tracking, active queue filtering, and queue replication. Added state persistence for long-running puzzles with timer-based checkpointing.

## Changes Made

### 1. Conditional Invalidity Statistics
**Only track invalidity counters when -i flag is specified**:
- Added `trackInvalidity` boolean field to `StateProcessor`
- Constructor now accepts `trackInvalidity` parameter (passed from `config.invalidityStats`)
- `incrementInvalidityCounter()` only called when `trackInvalidity` is true
- Reduces atomic operations when detailed statistics aren't needed

```java
// In StateProcessor.processState()
if (invalidatingTest != null) {
    prunedCount++;
    if (trackInvalidity) {
        pendingStates.incrementInvalidityCounter(nextState.getMoveCount(), invalidatingTest.getName());
    }
    continue;
}
```

### 2. Active Queues Optimization
**Skip polling empty queues using boolean tracking**:
- Added `activeQueues` boolean array to `PendingStates`
- Same dimensions as `queuesByMoveCount` (now 2D with replication)
- In `add()`: sets `activeQueues[moveCount][queueIndex] = true`
- In `poll()`: skips queues where `activeQueues` is false
- Avoids polling queues that have never had states added

### 3. Queue Replication (-repl parameter)
**Distribute states across multiple queues to reduce contention**:
- New `-repl <N>` command-line parameter (default: 3)
- `queuesByMoveCount` changed from 1D to 2D array: `[maxMoveCount+1][replicationFactor]`
- Each move depth now has N replicated queues
- States distributed randomly across replicas to reduce lock contention

### 4. QueueContext Class
**Per-thread context for random queue selection**:
- New class `org.gerken.harmony.logic.QueueContext`
- Constructor takes replication factor
- `getRandomQueueIndex()` returns random int 0 to replicationFactor-1 using `ThreadLocalRandom`
- Each `StateProcessor` gets its own instance via `pendingStates.getQueueContext()`

```java
public class QueueContext {
    private final int replicationFactor;

    public QueueContext(int replicationFactor) {
        this.replicationFactor = replicationFactor;
    }

    public int getRandomQueueIndex() {
        return ThreadLocalRandom.current().nextInt(replicationFactor);
    }
}
```

### 5. Modified PendingStates Methods
**Updated for 2D queue structure**:
- Constructor: `PendingStates(int maxMoveCount, int replicationFactor)`
- `add(BoardState, QueueContext)`: uses random queue index from context
- `add(BoardState)`: uses queue index 0 (for initial state without context)
- `poll(QueueContext)`: polls from randomly selected queue at each depth
- `isEmpty()`, `size()`: iterate over all replicated queues
- `getSmallestNonEmptyQueueInfo()`, `getQueueRangeInfo()`: sum sizes across replicas

### 6. StateProcessor Integration
**Uses QueueContext for queue operations**:
- Added `queueContext` field
- In `run()`: calls `pendingStates.getQueueContext()` once at thread start
- `getNextBoardState()`: passes `queueContext` to `poll()`
- `storeBoardState()`: passes `queueContext` to `add()`

## Files Modified

- `src/main/java/org/gerken/harmony/HarmonySolver.java` - Duration timer, state persistence, resumption logic
- `src/main/java/org/gerken/harmony/logic/PendingStates.java` - 2D arrays, replication, collectAllStates()
- `src/main/java/org/gerken/harmony/logic/StateProcessor.java` - trackInvalidity flag, getCachedStates()

## Files Created

- `src/main/java/org/gerken/harmony/logic/QueueContext.java` - Per-thread queue selection context
- `src/main/java/org/gerken/harmony/logic/StateSerializer.java` - State persistence and loading

## Command Line Options (Updated)

```bash
./solve.sh [options] <puzzle-file>

Options:
  -t, --threads <N>     Number of worker threads (default: 2)
  -r, --report <N>      Progress report interval in seconds (default: 30, 0 to disable)
  -c, --cache <N>       Cache threshold: states with N+ moves taken are cached locally (default: 4)
  -repl <N>             Replication factor for queue distribution (default: 3)
  -d, --debug           Debug mode: disable empty queue termination
  -i, --invalidity      Show invalidity test statistics instead of queue sizes
  --smallestFirst       Process moves with smallest tile sum first
  --largestFirst        Process moves with largest tile sum first
  -h, --help            Show this help message
```

### 7. State Persistence (-dur/--duration)
**Timer-based checkpointing for long-running puzzles**:
- New `-dur, --duration <N>` command-line parameter (default: 120 minutes)
- When time expires, collects all states and saves to `<puzzle>.state.txt`
- On startup, checks for existing state file and resumes if found
- State file format: one line per state with move history as space-separated notations
- Statistics restart from zero when resuming
- Handles changing replication factors and thread counts between runs

**Graceful shutdown behavior**:
- When time expires, `solutionFound` flag signals threads to stop accepting new work
- Threads finish processing their current in-progress board state
- System waits 10 seconds for all in-progress work to complete
- Then collects states from queues and caches for persistence

### 8. StateSerializer Class
**Serialization/deserialization of board states**:
- `getStateFilePath(puzzleFile)`: Derives state file path from puzzle file
- `stateFileExists(puzzleFile)`: Checks for existing state file
- `saveStates(puzzleFile, states)`: Saves all states to file
- `loadStates(puzzleFile, initialState)`: Loads and reconstructs states
- `deleteStateFile(puzzleFile)`: Removes state file when solution found

State file format:
```
# Harmony State File
# States: N

A1-B1 B2-C2 C1-C3
A1-B1 A2-B2
INITIAL
```

## Design Decisions

1. **Conditional statistics**: Invalidity tracking has overhead; skip when not needed
2. **Active queue tracking**: Simple boolean avoids polling never-used queues
3. **Queue replication**: Reduces ConcurrentLinkedQueue contention with multiple threads
4. **Per-thread QueueContext**: Each thread gets independent random selection, no shared state
5. **Random distribution**: States spread evenly across replicas over time
6. **Accept empty polls**: It's OK if poll() returns null when other replicas have states; maintains depth-first behavior while reducing contention
7. **Move-based serialization**: Store move history rather than full board state; replay to reconstruct
8. **Timer-based persistence**: ScheduledExecutorService triggers clean shutdown and save
9. **Graceful shutdown**: Wait 10 seconds for in-progress states to complete before saving; ensures no partial work is lost

## Test Results

All puzzles verified working with various replication factors:
- tiny.txt (2x2, 4 moves): Works with -repl 1, 3, 5
- simple.txt (3x3, 9 moves): Works with -repl 1, 3, 5
- 3x3_8moves.txt: Works with -repl 4
- Duration feature tested with -dur 1
