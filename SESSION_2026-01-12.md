# Session Summary - January 12, 2026

## Overview
Performance optimizations focused on reducing atomic operations, simplifying data structures, and batch processing.

## Changes Made

### 1. PendingStates Refactored for Performance

**Array-based queue storage**:
- Changed from `ConcurrentHashMap<Integer, ConcurrentLinkedQueue<BoardState>>` to `ConcurrentLinkedQueue<BoardState>[]`
- All queues pre-created at initialization based on known max move count
- Direct array indexing instead of map lookups

**Simplified maxMoveCount**:
- Changed from `AtomicInteger` to simple `int`
- Set once during construction from initial state's remaining moves
- No more atomic updates during execution

**Simplified solutionFound**:
- Changed from `AtomicBoolean` to `volatile boolean`
- `markSolutionFound()` now returns `void` instead of `boolean`

**Batch counter methods**:
- Added `addStatesGenerated(int count)`
- Added `addStatesPruned(int count)`
- Replaced individual increment calls with batch updates

### 2. StateProcessor Optimizations

**Move sorting flags** (`--smallestFirst` / `--largestFirst`):
- Added `SortMode` enum: `NONE`, `SMALLEST_FIRST`, `LARGEST_FIRST`
- Comparator compares moves by sum of remaining moves of both tiles
- Mutually exclusive command-line flags

**Optimized solution check**:
- Only call `isSolved()` when `remainingMoves == 0`
- Board with remaining moves cannot be solved

**Batched counter updates**:
- Count generated/pruned locally in loop
- Single batch update after loop completes
- Reduces atomic operation overhead

**Removed inner loop solution check**:
- Removed `isSolutionFound()` check from inside move iteration loop
- Threads complete current state before checking at main loop level

**Pre-sized cache**:
- ArrayList cache initialized with capacity 100,000
- Avoids resize operations during execution

### 3. Tile Class

**Added copy() method**:
```java
public Tile copy() {
    return new Tile(color, remainingMoves);
}
```

**Benchmark results**:
- Array `clone()`: 1.7ms for 1M tiles
- `Tile.copy()`: 35ms for 1M tiles
- `clone()` is 20x faster - kept using clone()

### 4. BlockedSwapTest Simplified

**Removed findTargetRowForColor() method**:
- Target row equals tile's color (by convention)
- Replaced lookup with direct assignment: `int targetRow = tile.getColor();`

### 5. New Test Puzzles

Created with PuzzleGenerator:
- `puzzles/3x3_8moves.txt` - 3x3 grid, 8 moves
- `puzzles/4x4_9moves.txt` - 4x4 grid, 9 moves
- `puzzles/3x3_12moves.txt` - 3x3 grid, 12 moves

### 6. New Utility Class

**TileBenchmark.java**:
- Compares Tile.copy() vs array clone() performance
- 1 million tile array, 10 test iterations
- Located in `src/main/java/org/gerken/harmony/`

## Files Modified

- `src/main/java/org/gerken/harmony/HarmonySolver.java` - SortMode enum, new flags
- `src/main/java/org/gerken/harmony/logic/PendingStates.java` - Array-based queues, simplified atomics
- `src/main/java/org/gerken/harmony/logic/StateProcessor.java` - Sorting, batching, optimizations
- `src/main/java/org/gerken/harmony/model/Tile.java` - Added copy() method
- `src/main/java/org/gerken/harmony/model/BoardState.java` - isSolved() early exit optimization
- `src/main/java/org/gerken/harmony/invalidity/BlockedSwapTest.java` - Removed findTargetRowForColor()

## Files Created

- `src/main/java/org/gerken/harmony/TileBenchmark.java` - Performance benchmark
- `puzzles/3x3_8moves.txt` - Test puzzle
- `puzzles/4x4_9moves.txt` - Test puzzle
- `puzzles/3x3_12moves.txt` - Test puzzle

## Command Line Options (Updated)

```bash
./solve.sh [options] <puzzle-file>

Options:
  -t, --threads <N>     Number of worker threads (default: 2)
  -r, --report <N>      Progress report interval in seconds (default: 30)
  -c, --cache <N>       Cache threshold (default: 4)
  -d, --debug           Debug mode
  -i, --invalidity      Show invalidity statistics
  --smallestFirst       Process moves with smallest tile sum first
  --largestFirst        Process moves with largest tile sum first
  -h, --help            Show help message
```

## Test Results

All puzzles verified working:

| Puzzle | Moves | Processed | Generated | Pruned |
|--------|-------|-----------|-----------|--------|
| tiny | 4 | 4 | 4 | 0% |
| simple | 9 | 23.0K | 33.3K | 30.7% |
| 3x3_8moves | 8 | 147 | 219 | 26.0% |
| 4x4_9moves | 9 | 37 | 65 | 20.0% |
| 3x3_12moves | 12 | 21 | 136 | 6.6% |

### 7. BoardState.isSolved() Optimization

**Early exit on remainingMoves check**:
- Added check for `remainingMoves != 0` before delegating to `board.isSolved()`
- O(1) integer comparison avoids O(rows × cols) tile iteration when moves remain
- Safe because a board with remaining moves cannot be solved

```java
public boolean isSolved() {
    if (remainingMoves != 0) {
        return false;
    }
    return board.isSolved();
}
```

### 8. Board Grid Copy Benchmark (Temporary)

**Tested clone() vs manual loop copy**:
- Created `BoardCopyBenchmark.java` to compare implementations
- Both create new arrays but share same immutable Tile references
- Results: `clone()` is 4-5x faster than manual copy loop
- clone() uses native bulk memory copy; manual has per-element overhead
- Benchmark deleted after confirming clone() is optimal

| Size | clone() | Manual | Winner |
|------|---------|--------|--------|
| 3x3 | 34.7ms | 145.2ms | clone() 4.2x faster |
| 4x4 | 40.8ms | 187.2ms | clone() 4.6x faster |

## Key Design Decisions

1. **Pre-allocated queues**: Since max moves known upfront, no need for dynamic creation
2. **Volatile over AtomicBoolean**: Solution flag only transitions false→true once
3. **Batch counter updates**: Reduces contention on atomic counters
4. **Keep clone() over copy()**: 20x performance difference for array copying
5. **Direct color→row mapping**: Eliminates search loop in BlockedSwapTest
6. **isSolved() early exit**: O(1) check before O(n²) tile iteration
7. **clone() for grid copy**: 4-5x faster than manual element-by-element copy
