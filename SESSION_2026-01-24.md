# Session 15 - January 24, 2026

## Summary
Changed PendingStates to score-based queue indexing, updated cache threshold to use board scores, added 'first' flag to BoardState for tracking primary search path, and enhanced state restoration with sorting.

## Changes Made

### 1. Score-Based Queue Indexing (`PendingStates.java`)

**Changed from moves-remaining to board-score indexing**:
- Constructor now takes `initialScore` instead of `maxMoveCount`
- `maxScore = initialScore + 6` (scores above max stored in max queue)
- `add()` uses `state.getBoard().getScore()` for queue index
- `poll()` returns from LOWEST score queue first (lower = closer to solution)

**Rationale**: Lower board scores indicate states closer to the solution. By prioritizing low-score states, the solver focuses on promising search paths first.

### 2. Score-Based Cache Threshold (`StateProcessor.java`, `HarmonySolver.java`)

**Changed -c flag meaning from moves-taken to board-score**:
- Old: "cache states with N+ moves taken"
- New: "cache states with board score >= N"

```java
// Old logic
if (movesTaken >= cacheThreshold) { cache.add(state); }

// New logic
if (boardScore >= cacheThreshold) { cache.add(state); }
```

**Effect**: High-score states (far from solution) are cached locally, while low-score states (close to solution) go to shared queue for priority processing by any thread.

### 3. ProgressReporter Queue Display Order (`ProgressReporter.java`)

**Reversed display order**:
- Was: lowest score to highest (left to right)
- Now: highest score to lowest (left to right)
- Lower scores (closer to solution) now appear on the right

### 4. BoardState 'first' Flag (`BoardState.java`)

**New boolean flag tracking primary search path**:
```java
private boolean first = false;

public boolean isFirst() { return first; }
public void setFirst(boolean first) { this.first = first; }

public BoardState applyMove(Move move, int possibleMoveCount) {
    // ...
    if (this.first && possibleMoveCount == 1) {
        newState.setFirst(true);
    }
    return newState;
}
```

**Propagation logic**:
- BoardParser sets `first=true` on initial state
- `applyMove(Move, int possibleMoveCount)` propagates `first=true` only when:
  - Parent state has `first=true` AND
  - There is exactly one possible move from parent
- Otherwise new state has `first=false`

### 5. storeBoardStates() First Flag Logic (`StateProcessor.java`)

**Cache all states when parent is on primary path**:
```java
private void storeBoardStates(List<BoardState> states) {
    if (!states.isEmpty() && states.get(0).getPreviousBoardState().isFirst()) {
        BoardState parent = states.get(0).getPreviousBoardState();
        if (parent != null && parent.isFirst()) {
            for (BoardState state: states) {
                state.setFirst(states.size() == 1);
            }
            cache.addAll(states);
            return;
        }
    }
    // Normal score-based caching logic...
}
```

**Effect**: When parent is on primary search path (first=true), all child states are cached locally. Child states get `first = (states.size() == 1)` to continue the chain only if there's exactly one valid move.

### 6. Resume State Sorting (`HarmonySolver.java`)

**Sort restored states by remaining moves when resuming**:
```java
if (resumeStates != null && !resumeStates.isEmpty()) {
    resumeStates.sort((s1, s2) ->
        Integer.compare(s1.getRemainingMoves(), s2.getRemainingMoves()));
    // ...add to queues
}
```

**Effect**: States closest to solution (least remaining moves) are added to queues first, enabling faster solution discovery on resume.

### 7. Display Board Score on Startup (`HarmonySolver.java`)

**Added board score display after loading puzzle**:
```
Board size:     4x4
Board score:    48
Moves required: 30
```

## Files Modified

| File | Changes |
|------|---------|
| `PendingStates.java` | Score-based indexing, poll from lowest score |
| `StateProcessor.java` | Score-based cache threshold, first flag logic |
| `ProgressReporter.java` | Reversed queue display order (max to 0) |
| `BoardState.java` | Added first flag, applyMove with possibleMoveCount |
| `BoardParser.java` | Sets first=true on initial state |
| `HarmonySolver.java` | Displays board score, sorts resume states, updated help text |

## Testing

All puzzles solve correctly with the new score-based approach:

| Puzzle | Size | Score | Moves | Processed | Pruned |
|--------|------|-------|-------|-----------|--------|
| puzzle-4x4-easy.txt | 4x4 | 4 | 8 | 80 | 10.7% |
| test_001.txt | 4x4 | 10 | 7 | 10 | 0% |
| 5x5x12.txt | 4x4 | 48 | 30 | 334 | 42.9% |

## Design Rationale

### Why Score-Based Indexing?
The board score heuristic (from Session 14) measures "distance from solution":
- Lower score = closer to solution
- Solved board has score 0

By organizing queues by score and polling from lowest score first, the solver prioritizes states most likely to lead to a solution. This is more effective than moves-remaining because it considers board configuration quality, not just move count.

### Why the 'first' Flag?
The primary search path (following the first/only valid move at each step) often leads directly to a solution for well-structured puzzles. By:
1. Keeping this path in one thread's local cache
2. Processing it depth-first (LIFO)

We maximize the chance of finding a solution quickly without the overhead of shared queue contention.

### Why Sort Resume States?
When resuming a long-running search, we want to immediately focus on the most promising states. Sorting by remaining moves (least first) ensures states closest to completion are processed first after resume.
