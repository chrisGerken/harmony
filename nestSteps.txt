1) Add a new command line integer parameter -repl (for "replication factor") with default value of 3. Pass this value to the PendingStates constructor which will store in a new instance variable replicationFactor.

2) Create a new class QueueContext whose contructor will take an integer replication factor. Add a method to this class to answer a random integer between 0 and replicationFactor-1, inclusive. Add a zero argument method getQueueContext() on class PendingStates that returns a newly created QueueContext instance.

3) Each instance of StateProcessor will call PendingStates once to get its own instance of QueueContext. StateProcessor will never interact with this instance other than to pass it to several PendingStates methods.

4) In PendingStates there is a variable queuesByMoveCount with one ConcurrentLinkedQueue for each number of moves.  modify the declaration and use so that there is now a second dimension whose length is the replication factor. For example if the replication factor is 4 then instead of one ConcurrentLinkedQueue holding board states that have been through five moves there will be 4 such ConcurrentLinkedQueues with those 5-move board states distributed sort of evenly across the 4 ConcurrentLinkedQueues. 

5) Modify the add(BoardState) and poll() methods on PendingStates to accept an additional arguement, a QueueContext. Modify the implementation of add to ask the QueueContext for a random number between 0 and replicationFactor-1 inclusive and to write the given BoardState to the corresponding ConcurrentLinkedQueue. Similarly, the QueueContext will provide a random number to specify which of the queues the PendingStates poll() method should poll.  It's OK if poll(QueueContext) polls an empty queue when there are other queues that have BoardStates. We maintain the depth-first design while reducing contention during reads and writes to the queues.

