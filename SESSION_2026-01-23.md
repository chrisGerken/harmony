# Session 14 - January 23, 2026

## Summary
Added board scoring system with lazy calculation, created ScoreWatcher utility for analyzing scoring heuristic effectiveness, and refactored StateProcessor to batch collect valid states before storage.

## Changes Made

### 1. Board Scoring System (`Board.java`)

**Added lazy-calculated heuristic score**:
- New `Integer score` attribute (null until calculated)
- New `getScore()` method that calculates and caches score on first access
- Score formula (sum of three components):
  1. Number of tiles NOT in their target row (target row = color ID)
  2. For each column: (tiles in column) - (unique colors in column)
  3. For each tile with > 2 remaining moves: (remaining moves - 2)
- Updated both `toString()` methods to append "Score: N" on its own line

**Design rationale**:
- Lower score = closer to solution (solved board has score 0)
- Lazy calculation avoids overhead when score isn't needed
- Score cached to avoid recalculation

### 2. ScoreWatcher Utility (`ScoreWatcher.java`)

**New class for analyzing scoring heuristic effectiveness**:
- Generates random puzzles using TestBuilder
- Reports score progression through entire solution path
- Output columns: Move, Action, Score, Valid, Min, Max, Rank, Percentile
- Only marks score increases with ↑ (score going up = getting worse)
- Statistics: average percentile, optimal move rate, score increase rate

**Usage**:
```bash
java -cp target/harmony-solver.jar org.gerken.harmony.ScoreWatcher 6 6 40
```

**Sample output**:
```
Move  Action       Score  Valid   Min   Max   Rank Percentile
Start -               54      -     -     -      - -
1     E2-E3         52      124    51    56      7   95.2%
2     F2-F4         49      124    49    54      1  100.0%
...
Statistics:
  Average percentile: 91.5%
  Optimal moves (rank 1): 12/40 (30.0%)
  Score increases: 0/40 (0.0%)
```

### 3. TestBuilder Enhancement (`TestBuilder.java`)

**Added static method for programmatic puzzle generation**:
```java
public static BoardState[] generatePuzzleWithSolution(int rows, int cols, int numMoves)
public static BoardState[] generatePuzzleWithSolution(int rows, int cols, int numMoves, Random random)
```
- Returns `BoardState[]` where element 0 is initial scrambled state
- Subsequent elements (1 to numMoves) show state after each solution move
- Overloaded version accepts `Random` for reproducible puzzles
- Added helper `generateRandomMove()` for creating valid random moves

### 4. StateProcessor Refactoring (`StateProcessor.java`)

**Changed from immediate storage to batch collection**:

Before:
```java
for (Move move : possibleMoves) {
    // ... validation ...
    storeBoardState(nextState);  // Called immediately
}
```

After:
```java
List<BoardState> validStates = new ArrayList<>();
for (Move move : possibleMoves) {
    // ... validation ...
    validStates.add(nextState);  // Collect first
}
storeBoardStates(validStates);  // Store all at once
```

**Method renamed**:
- `storeBoardState(BoardState)` → `storeBoardStates(List<BoardState>)`
- Iteration now happens inside `storeBoardStates()`

**Benefits**:
- Enables future enhancements like sorting valid states by score
- Cleaner separation of validation and storage logic

## Files Modified

| File | Changes |
|------|---------|
| `Board.java` | Added score attribute, getScore(), calculateScore(), updated toString() |
| `TestBuilder.java` | Added generatePuzzleWithSolution(), generateRandomMove() |
| `StateProcessor.java` | Batch collection in processState(), storeBoardStates(List) |

## Files Created

| File | Purpose |
|------|---------|
| `ScoreWatcher.java` | Utility to analyze scoring heuristic effectiveness |

## Testing

All existing puzzles still solve correctly:
- puzzle-4x4-easy.txt: ✓ Solved (8 moves)
- test_001.txt: ✓ Solved (7 moves)
- 5x5x12.txt: ✓ Solved (30 moves)

ScoreWatcher tested with various puzzle sizes:
- 4x4 with 15 moves: ✓ Works, avg percentile ~86%
- 6x6 with 40 moves: ✓ Works, avg percentile ~90%

## Observations from ScoreWatcher Analysis

1. **Scoring heuristic is reasonably effective**: Average percentile typically 85-95%
2. **Optimal moves**: Solution move is rank 1 about 30% of the time
3. **Score increases are rare**: Most solution moves maintain or decrease score
4. **End-game is predictable**: As options narrow, solution move is almost always optimal
5. **Mid-game has more variance**: Lower percentiles occur when many alternatives exist

## Next Steps (Potential)

1. **Score-based move ordering**: Sort valid states by score before storing
2. **Heuristic refinement**: Adjust scoring formula based on ScoreWatcher analysis
3. **A* search**: Use score as heuristic for guided search
4. **Benchmarking**: Compare solve times with/without score-based ordering
